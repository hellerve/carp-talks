\documentclass[14pt,aspectratio=169]{beamer}
\usepackage{minted}
\usemintedstyle{borland}
\usepackage{listings}
\usetheme{veit}
\title{Carp}
\subtitle{A Programming Language for the 21st Century}
\date{\today}
\author{Veit Heller}
\institute{Port Zero}
\begin{document}
  \maketitle
  \section{Prologue}
  \begin{frame}{Obligatory Starter}
    \begin{itemize}
      \item Carp standard library maintainer
      \item CTO @ Port Zero
      \item Secretly a turtle
    \end{itemize}
  \end{frame}
  \begin{frame}{Obligatory Starter}
    I didn’t build Carp.
    \linebreak

    I maintain parts of it, but all credit goes to Erik Svedäng (hi, Erik!).
    \linebreak

    This talk is not endorsed by him, and all opinions are my own.
  \end{frame}
  \begin{frame}{Questions \& Comments}
    This is a chess-timer talk. Ask questions at any time.
    \linebreak

    I can’t promise that I’ll be able to answer all of them.
    \linebreak

    I probably won’t get through my material.
  \end{frame}
  \section{I. Syntax \& other trivialities}
  \begin{frame}{Koalas}
    Let’s talk koalas.
  \end{frame}
  \begin{frame}{Koalas}
    Koalas are endangered!
    \linebreak

    Consider donating to the Australian Koala Foundation.
    https://www.savethekoala.com/
  \end{frame}
  \begin{frame}{What?}
    Carp’s syntax is that of Lisp, parentheses and all.
  \end{frame}
  \begin{frame}{Why?}
    The goal is homoiconicity or “code as a data structure”.
  \end{frame}
  \begin{frame}[fragile]
  \frametitle{Carp code}
    \begin{listing}[H]
      \caption{A silly Carp function}
      \begin{minted}{clojure}
; (type f)
; f : (Fn [(Ref (Array a)), Int, Int] a)
(defn f [x y z]
  @(Array.nth x (* y z)))
      \end{minted}
    \end{listing}
  \end{frame}
  \begin{frame}[fragile]
    \frametitle{Carp code}
    \begin{listing}[H]
      \caption{An associative array type, simplified.}
      \begin{minted}{clojure}
(deftype (AssocArray a b) [
  lst (Array (Pair a b))
])
      \end{minted}
    \end{listing}
  \end{frame}
  %\section{Interlude: Demo}
  \section{II. Semantics \& meaning}
  \begin{frame}{The goods}
    We have (non-hygienic) macros, type inference, and a borrow checker.
    \linebreak

    The emphasis of the design is on simplicity while being pragmatic.
  \end{frame}
  \begin{frame}{What we’re still tuning}
    We’re working on

    \begin{itemize}
      \item good autogenerated documentation,
      \item dependency management,
      \item lifetimes, and
      \item tooling in general.
    \end{itemize}
  \end{frame}
  \begin{frame}{Why?}
    There’s a vast amount of information flowing through the compiler.
    \linebreak

    Most of it is implicit. \linebreak

    Reducing cognitive load is useful, but explorability is key.
  \end{frame}
  \begin{frame}{Why?}
    Everything should be inferred if possible, and exposed to our tools to help
    make our lifes easier.
  \end{frame}
  \begin{frame}{Why?}
    I was fortunate enough to use Pharo professionally last year.
    \linebreak

    It’s really that good.
  \end{frame}
  \begin{frame}{What?}
    Macros are interesting abstractions. \linebreak

    I want to be able to explore their before, during, and after.
  \end{frame}
  \begin{frame}{What?}
    Type inference is useful. \linebreak

    Most types are either trivial or painful to type, but easy to reason about.
    \linebreak

    I still want to know about the types occasionally. Especially when there was
    a misunderstanding.
  \end{frame}
  \begin{frame}{What?}
    I don’t want to deal with memory allocation. \linebreak

    I don’t want my program to pause randomly.
    \linebreak

    And I want to know when things get deallocated because their scope ends.
  \end{frame}
  \begin{frame}{The big reveal}
    We don’t have any tools yet.
  \end{frame}
  \begin{frame}{The big reveal}
    We’ve built a foundation, and released it. \linebreak

    Now it’s time for us to get to work on interesting things.
  \end{frame}
  \section{III. Recap}
  \begin{frame}{Why am I here?}
    Designing a language is about affordances.
  \end{frame}
  \begin{frame}{Macros?}
    Macros give you a unique ability to abstract.
    \linebreak

    They also blow up all the time, and leave a mess.
  \end{frame}
  \begin{frame}{Typing?}
    Static types give you explorability and ahead-of-time guarantees.
    \linebreak

    Dynamic types give you velocity and malleability.
  \end{frame}
  \begin{frame}{Memory management?}
    Manual memory management give you memory layout control.
    \linebreak

    Garbage collection gives you (better) memory safety.
    \linebreak

    Borrow checking gives you safety without runtime pauses.
  \end{frame}
  \begin{frame}{And Carp?}
    Carp pushes as much work as possible into the compiler. \linebreak

    Hopefully tools can pull the results of that work out again.
  \end{frame}
  \begin{frame}{Caveat}
    Carp is early stage software.
    \begin{itemize}
      \item[$\Rightarrow$] We’re a small community with few packages.
      \item[$\Rightarrow$] We’re less than a handful of maintainers.
      \item[$\Rightarrow$] Documentation is insufficient.
      \item[$\Rightarrow$] It may change under your feet.
      \item[$\Rightarrow$] It may blow up in your face!
    \end{itemize}
    Our first stable release—0.3.0—was !
  \end{frame}
  \begin{frame}{References}
    \begin{itemize}
      \item Github: \texttt{https://github.com/carp-lang/carp}
      \item Erik: \texttt{https://github.com/eriksvedang}
      \item Chat: \texttt{https://gitter.im/carp-lang/carp}
      \item Docs: \texttt{http://carp-lang.github.io/Carp/core/}
      \item Blog: \texttt{https://blog.veitheller.de}
      \item This talk, but different, shorter, and at clojuTRE: \texttt{https://youtu.be/BQeG6fXMk28}
      \item Carp 0.3.0: \texttt{https://github.com/carp-lang/Carp/releases/}
    \end{itemize}
  \end{frame}
  \begin{frame}{Epilogue}
    \Huge Thank you!
    \linebreak
    \linebreak
    \linebreak
    \small Questions?
    \linebreak
    \linebreak
    \tiny Slides at \texttt{https://github.com/hellerve/carp\_talks}
  \end{frame}
\end{document}
