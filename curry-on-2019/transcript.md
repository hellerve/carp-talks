Hello everybody, I’m Veit, and today I’m going to talk about Carp.

Firstly, I’ll have to make clear that I didn’t build Carp. A talented game
designer from Sweden named Erik Svedäng came up with the idea for Carp. I’m
mostly taking care of the standard library and other libraries, and do the
occasional compiler fix. However, this talk is not endorsed by him or anyone
else involved in the development of Carp, and everything I’m going to say is
purely how I see it.

Also, this is a chess timer talk, which means that you can ask questions
whenever you want. I can’t promise that I’ll be able to answer all of them, but
if I can’t I’ll be upfront about it.

So, let’s start by talking about the syntax. I called this section “Syntax and
other trivialities”, because I honestly believe that the syntax is the least
interesting part about any language. I’m going to show you some code anyway,
because it feels kind of silly talking about a language without showing it, but
I mainly want to talk about some of the ideas in Carp, and why we went with
certain things rather than with others.

Let’s talk about koalas. Many people call koalas “koala bears”, but technically
they’re not bears at all. Botanically, they’re marsupials, which makes them
closer to kangurus and quokkas than to bears. Still, they look like bears, and
so people call them koala bears. In the same vein, Carp looks like Lisp, and so
people call it a Lisp, when programming in it actually feels closer to working
with MLs, like Haskell or OCaml, or even like Rust, rather than Lisp.

But what I’m saying with all of this is basically: Carp’s syntax is that of
Lisp, and it features parentheses.

I personally enjoy that syntax for its homoiconicity, which is a fancy word for
“what you see is what you get”. Our code is a data structure, and especially
for certain features of Carp, this is very useful.

Now would probably be the best time to look at some code, so let’s do just
that. At a first glance, Carp might look like Clojure, or maybe if you squint
even like Racket or Scheme or Common Lisp, depending on what you’ve worked
with. Basically, it looks like a Lisp. Here we’re creating a function `f` that
takes three arguments `x`, `y`, and `z`, and it will take the nth element of
the array `x`, determined by the product of `y` and `z`, and make a copy of
that element—which is what the little @ symbol is for. Now, if we ask Carp what
the type of this function is, it will tell us that it’s a function that takes
a reference to an array containing elements of type `a`—`a` is a type
variable—and it also takes two integers, which makes sense because we index an
array using integers, and the function will return a thing of type `a`, which
is the same type `a` that we had in the array. Basically, type variables work
like generics work in other languages, and they are inferred. To use a bit of
technical jargon, we’re using a Hindley—Milner type system enriched by sum
types, which are basically types with multiple constructors.

Here’s how we define a type with exactly one constructor in Carp, in this case
a generic associative array. An associative array is basically a list of
key-value pairs, a kind of linear hashmap. If you’ve worked through something
like, say, the Structure and Interpretation of Computer Programs you’ve seen
this; it’s a slow hashmap or dictionary structure. But basically, we’re
defining it to be a type with one member, `lst`, which is an array of pairs from
`a` to `b`, where those are again type variables. We also have to capture those
variables in the head of the definition. All of those are technicalities, but
now you know how to define your own types in Carp. Exciting! And this is about
as much as I’m going to show you about the language. Because now I want to talk
about “meaning”.

Specifically, I want to talk about the semantics of the language, and why you
might choose the features we chose, and why not, and certain tradeoffs about
them. And by the end you’ll hopefully understand what Carp is, and why at least
I think it’s fairly interesting. And if I do a really good job, everyone will
leave the talk with the visceral feeling that designing and building a language
is all about affordances.

So, let’s talk about the PL goodies first. We have non-hygienic macros, type
inference—using the Hindley—Milner system as I mentioned before—and a borrow
checker inspired by Rust. If any of these features don’t mean much to you, I’ll
get to them a little bit more in depth later. Generally, what Carp tries to do
is marry simplicity with pragmatism, and the question we always ask ourselves
is “how can we add as little as possible to make this ergonomic”.

And what we’re currently working on is autogenerated documentation and
dependency management—we have answers to both of these, but they’re not really
good enough yet—, lifetimes—which is a concept related to borrow-checkers—, and,
generally, tooling—which is what I’m interested in.

And why am I interested in that? Well, the compiler has a lot of moving parts
with a lot of information flowing through them about types and lifetimes and
macro expansions and the like. Most of it is implicit, because it’s inferred by
the compiler; nobody has typed these things out, they’re things that are true
about your program that you haven’t actually specified. That’s useful, because
it reduces cognitive load for the programmer and lets them focus on the
interesting bits, but occasionally you have to go and look at these inferred
things, and that’s where tools come into play to help you gain insights and
explore.

In a nutshell, Carp believes that everything should be inferred if possible and
exposed through tools to help us. We should only have to worry about these
things if we need to.

And at this point I want to give a little shoutout to Pharo, because it really
deeply informed my beliefs here. I was fortunate enough to use it professionally
last year, and today, in a session jsut before mine Tudor Girba talked about it.
I’m not going to rehash points that he made much more eloquently than I could
ever have, but as a user I can testify just how good it felt programming Pharo,
especially with the Glamorous Toolkit that he’s building. It’s probably the best
programming environment I’ve ever worked in, and this is purely attributable to
its tools. I don’t care much about Smalltalk one way or another, but I do care
about writing programs, and the environment made that part really easy. It was
great. And it got me thinking about how to get this kind of joy into other
environments, maybe statically typed or compiled ones, environments that already
have a lot of information just lying around. And I’m going to talk a little bit
about the ones Carp has, what they’re doing, and how tools can improve their
explorability.

I’m going to start with macros. Macros are great. I love writing them.
Debugging—not so much. Lisp macros are incredibly powerful, and because of the
homoiconicity, very easy to write. But they can be extremely frustrating,
especially when they generate code that is valid but doesn’t do what you want it
to do. And that’s where tools come in. Tools can help you explore what your
program looked like every step of the way—before the expansions, while the
expansion happened, and after it happened. It’s a tremendous boost of
productivity.

Type inference is similar. It’s super useful, because most types that you write
in your programs are either very trivial—especially if you write numeric code—,
or very painful to type but easy to reason about, such as when using higher order
functions. Fold, for instance, is a pretty simple operation, but its type
signatures are mostly atrocious. And by infering those types, all of that mental
load goes away. But sometimes, we really do need to knwo what the types of
things are, especially if there is a misunderstanding between us and the machine,
something we thought might be possible but is actually invalid. And again,
tooling is key to make this affordable.

And lastly, borrow checking. And because this is the newest and most unusual
feature I’m talking about today, I’m going to give you a bit of an intuition
about what it is. Basically, borrow-checking is a way for the compiler to figure
out the lifetimes of values statically, meaning that the compiler figures out
when to allocate and deallocate things at compile time, without you having to
tell it. So, it is different from manual memory management because it’s
inferred, and it’s different from garbage collection because it happens at
compile time, and there are no random pauses where the runtime searches for
unused values.

And, basically, I don’t want to deal with memory amangement. Often enough it
is pretty mundane, and unless I really want to enforce a certain layout, I
don’t need to know anything about it. But I also don’t want my program to pause
randomly, especiall in timing-sensitive applications like games, which is the
domain Carp comes from, remember. What I want is for the compiler to figure
those things out for me, and if I need to optimize, then I want to be able to
see the lifetimes of values, and where things happen under the hood.

And now we come to the sad part of the talk, because Carp doesn’t have any
great tools for this yet. It has facilities for you to expand macros and it
can give you informations about types, but there are basically no tools around
it.

What we did do is build a foundation, a first release, and push it out to the
world. Now we have to tend to that foundation, but hopefully we get to spend
more time on things like tooling and libraries, and generally more interesting
stuff.

So, if none of this has been built yet, why am I here? Basically, I’m here to
remind all of you that designing a language is all about affordances. Things
like static types might be a good idea, but they come with a real cost; working
in a dynamically types language often gives you greater velocity, especially
when you’re prototyping. What Carp does is push as much work as we know how to
do into the compiler, so you don’t have to deal with it. But we also need to
tools to remind us what this work was about, especially when we did something
unexpected. So hopefully tools are a way to tip the balance in favor of more
static languages.

At this point I’m going to leave you with a few pointers.

Most importantly, I encourage you to try Carp, of course, but don’t expect it
to answer any of your problems. It’s very early stage software, and that means
(rattle of list). But we just recently released the first stable version of
Carp, so maybe some of the shifting around will be less painful from now on.

I also have a page of references, but I encourage you to look at my slides
online and look at the links there. A link to my presentation is on the last
slide.

And, finally, a brief word about koalas, this talk’s main event: they are
endangered, so you might want to look into donating to the Australian Koala
Foundation, which tries to prevent koalas from going extinct.

Thank you! Do you have any other questions right now?
